1. Результати:
Для малих масивів (100 елементів)
| Алгоритм         | 1 запуск     | 2 запуск     | 3 запуск     |
|------------------|--------------|--------------|--------------|
| Insertion Sort   | 0.000120     | 0.000121     | 0.000130     |
| Merge Sort       | 0.000117     | 0.000104     | 0.000112     |
| Timsort          | 0.000033     | 0.000007     | 0.000008     |

Для середніх масивів (1000 елементів)
| Алгоритм         | 1 запуск     | 2 запуск     | 3 запуск     |
|------------------|--------------|--------------|--------------|
| Insertion Sort   | 0.015291     | 0.015094     | 0.014847     |
| Merge Sort       | 0.001678     | 0.001590     | 0.001672     |
| Timsort          | 0.021234     | 0.000080     | 0.000085     |

Для великих масивів (10000 елементів)
| Алгоритм         | 1 запуск     | 2 запуск     | 3 запуск     |
|------------------|--------------|--------------|--------------|
| Insertion Sort   | 0.000120     | 1.705677     | 1.713219     |
| Merge Sort       | 0.000117     | 0.018751     | 0.019024     |
| Timsort          | 0.000998     | 0.000981     | 0.001009     |


2. Аналіз отриманих результатів
Теоретична оцінка складностей:
Сортування вставками: O(n²) — ефективне тільки для малих масивів, але дуже повільне для великих.
Сортування злиттям: O(n logn) — стабільне для великих масивів і показує однакову ефективність для масивів різного розміру.
Timsort: O(n logn) — найкраще поєднує переваги сортування злиттям і вставками, а також оптимізоване для реальних даних.

Емпіричний аналіз:
Малі масиви (100 елементів): Сортування вставками, сортування злиттям і Timsort виконуються швидко, але сортування вставками може навіть мати перевагу через простоту.
Середні масиви (1000 елементів): Сортування злиттям і Timsort показують значно кращі результати, ніж сортування вставками.
Великі масиви (10000 елементів): Timsort і сортування злиттям показують найкращі результати. Сортування вставками не підходить через значно більший час виконання.


3. Висновки
З отриманих даних видно, що:

Timsort є найшвидшим алгоритмом на великих масивах, оскільки поєднує переваги сортування злиттям для розбиття масивів і сортування вставками для швидкого впорядкування малих підмасивів.

Сортування вставками добре працює лише на малих масивах, але стає надзвичайно повільним на великих масивах.

Сортування злиттям має стабільну продуктивність для великих масивів, але на малих масивах може бути менш ефективним, ніж Timsort.

Ці експерименти підтверджують теоретичні оцінки складностей і демонструють, чому Python використовує Timsort як вбудований алгоритм сортування. Він працює дуже ефективно на практиці, що робить його оптимальним вибором для більшості випадків.